# 논문 인용 관계 시각화 프로젝트 계획

이 문서는 논문 인용 및 참조 관계를 그래프로 시각화하는 프로젝트의 단계별 계획을 설명합니다. `citation_graph` 디렉토리 내에서 모든 작업을 진행합니다.

## 1단계: 데이터 수집 및 저장 (Data Crawling & Storage)

**목표:** 논문 정보와 논문 간의 인용/참조 관계 데이터를 수집하여 데이터베이스에 저장합니다.

**세부 실행:**

*   **크롤러 기능 확장:** `cawler/multi_platform_crawler.py` 크롤러를 수정하여 각 논문의 기본 정보(제목, 저자, 초록 등)뿐만 아니라, 해당 논문이 **인용하는 논문 목록(References)**과 해당 논문을 **인용한 논문 목록(Cited by)**을 함께 수집하도록 기능을 확장합니다. 이 과정에서 필요한 경우 논문 ID(DOI 등)를 활용하여 데이터를 연결합니다.
*   **데이터베이스 모델링:** 수집한 데이터를 저장할 데이터베이스 구조를 설계합니다. (예: SQLite `papers.db` 파일)
    *   `papers` 테이블: `id` (Primary Key, DOI 또는 고유 ID), `title`, `authors`, `year`, `abstract` 등의 정보를 저장합니다.
    *   `citations` 테이블: `citing_paper_id` (인용하는 논문 ID), `cited_paper_id` (인용되는 논문 ID)를 저장하여 논문 간의 관계를 표현합니다. 이는 `A논문이 B논문을 인용했다`는 방향성 있는 관계를 나타냅니다.
*   **데이터 저장 구현:** 크롤러에서 수집한 데이터를 설계된 데이터베이스 스키마에 맞춰 저장하는 로직을 구현합니다.

## 2단계: 백엔드 API 개발 (Backend API Development)

**목표:** 프론트엔드에서 시각화에 필요한 데이터를 요청하고 받아갈 수 있는 API를 만듭니다.

**세부 실행:**

*   **API 프레임워크 선택:** FastAPI를 사용하여 RESTful API를 구축합니다.
*   **API 엔드포인트 생성:** `/api/graph/{paper_id}`와 같은 엔드포인트를 추가하여 특정 논문 ID를 요청받으면 해당 논문과 관련된 인용/참조 관계 데이터를 반환하도록 합니다.
*   **데이터 처리 로직 구현:**
    *   요청된 `paper_id`에 해당하는 중심 논문 정보를 데이터베이스에서 조회합니다.
    *   중심 논문이 **인용하는** 논문들과 중심 논문을 **인용한** 논문들을 데이터베이스에서 조회합니다.
    *   중복된 노드를 제거하고, 각 논문을 노드(Node)로, 인용 관계를 엣지(Edge)로 표현합니다.
*   **JSON 형식으로 데이터 반환:** 시각화 라이브러리에서 사용하기 쉬운 JSON 형식(예: `{"nodes": [...], "edges": [...]}`)으로 데이터를 가공하여 반환합니다.
    *   **노드(Node) 스키마 예시:** `{"id": "paper123", "label": "논문 제목", "group": "central/cited/citing"}`
    *   **엣지(Edge) 스키마 예시:** `{"from": "paper123", "to": "paper456", "arrows": "to", "label": "cites/cited by"}`
*   **환경 설정 및 의존성 관리:** `requirements.txt` 파일을 통해 필요한 Python 라이브러리(FastAPI, Uvicorn, SQLAlchemy 등)를 명시하고 관리합니다.

## 3단계: 프론트엔드 시각화 구현 (Frontend Visualization)

**목표:** 백엔드 API로부터 받은 데이터를 사용하여 사용자가 볼 수 있는 인터랙티브한 그래프를 화면에 그립니다.

**세부 실행:**

*   **시각화 라이브러리 선택:** [Vis.js](https://visjs.org/), [D3.js](https://d3js.org/), [Cytoscape.js](https://js.cytoscape.org/) 등 인터랙티브 그래프를 쉽게 구현할 수 있는 JavaScript 라이브러리를 선택합니다.
*   **UI 구성 (HTML):** `index.html` 파일을 생성하여 그래프가 그려질 `canvas` 영역과 사용자가 논문을 검색할 입력창, 그래프 제어 버튼 등을 포함하는 기본적인 웹 페이지 구조를 만듭니다.
*   **데이터 연동 및 렌더링 (JavaScript):** `script.js` 파일을 생성하여 다음 로직을 구현합니다.
    *   사용자가 논문을 검색하면 백엔드의 API (`/api/graph/{paper_id}`)를 호출합니다.
    *   API로부터 받은 JSON 데이터를 파싱하여 노드와 엣지 데이터를 추출합니다.
    *   선택한 시각화 라이브러리를 사용하여 추출된 노드와 엣지를 웹 페이지에 인터랙티브 그래프로 렌더링합니다.
    *   줌(Zoom), 패닝(Panning), 노드 클릭 시 상세 정보 표시(예: 논문 초록 팝업, 해당 논문을 중심으로 그래프 다시 그리기) 등과 같은 사용자 상호작용 기능을 추가하여 사용성을 높입니다.
*   **스타일링 (CSS):** `style.css` 파일을 생성하여 웹 페이지와 그래프의 시각적인 요소를 디자인하고 사용자 경험을 개선합니다.

## 4단계: 통합 및 고도화 (Integration & Enhancement)

**목표:** 개발된 각 부분(크롤러, 백엔드, 프론트엔드)을 통합하고 전체 시스템이 원활하게 동작하는지 테스트하며 기능을 개선합니다.

**세부 실행:**

*   **엔드투엔드(End-to-End) 테스트:** 데이터 수집부터 최종 시각화까지 전체 흐름을 테스트하고 발생 가능한 버그를 수정합니다.
*   **성능 최적화:** 대규모 데이터 시각화 시 발생할 수 있는 성능 문제를 해결하기 위해 데이터 로딩, 렌더링 최적화 등을 고려합니다.
*   **에러 핸들링 및 로깅 강화:** 각 단계에서 발생할 수 있는 오류에 대한 적절한 예외 처리 및 상세 로깅 기능을 구현하여 문제 진단 및 해결을 용이하게 합니다.
*   **배포:** 개발된 시스템을 실제 사용 환경에 배포하기 위한 방안을 고려합니다 (예: Docker 컨테이너화, 클라우드 플랫폼 배포). 